<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/systems/RenderSystem.js | oxygen-core</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Oxygen game engine (Xenon Core for browsers)"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="oxygen-core"><meta property="twitter:description" content="Oxygen game engine (Xenon Core for browsers)"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/PsichiX/Oxygen"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-lazyInitialization">lazyInitialization</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#asset-loaders">asset-loaders</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/asset-loaders/AtlasAsset.js~AtlasAsset.html">AtlasAsset</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/asset-loaders/BinaryAsset.js~BinaryAsset.html">BinaryAsset</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/asset-loaders/FontAsset.js~FontAsset.html">FontAsset</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/asset-loaders/ImageAsset.js~ImageAsset.html">ImageAsset</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/asset-loaders/JSONAsset.js~JSONAsset.html">JSONAsset</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/asset-loaders/MusicAsset.js~MusicAsset.html">MusicAsset</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/asset-loaders/PackAsset.js~PackAsset.html">PackAsset</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/asset-loaders/ParticleSystemAsset.js~ParticleSystemAsset.html">ParticleSystemAsset</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/asset-loaders/SceneAsset.js~SceneAsset.html">SceneAsset</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/asset-loaders/ShaderAsset.js~ShaderAsset.html">ShaderAsset</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/asset-loaders/SkeletonAsset.js~SkeletonAsset.html">SkeletonAsset</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/asset-loaders/SoundAsset.js~SoundAsset.html">SoundAsset</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/asset-loaders/TextAsset.js~TextAsset.html">TextAsset</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#components">components</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/components/AtlasSprite.js~AtlasSprite.html">AtlasSprite</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/components/Camera.js~Camera.html">Camera</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/components/Camera2D.js~Camera2D.html">Camera2D</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/components/CameraDirector2D.js~CameraDirector2D.html">CameraDirector2D</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/components/InputHandler.js~InputHandler.html">InputHandler</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/components/InputListener.js~InputListener.html">InputListener</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/components/Particles.js~Particles.html">Particles</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/components/PhysicsBody.js~PhysicsBody.html">PhysicsBody</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/components/PhysicsWorld.js~PhysicsWorld.html">PhysicsWorld</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/components/PrefabInstance.js~PrefabInstance.html">PrefabInstance</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/components/RectangleRenderer.js~RectangleRenderer.html">RectangleRenderer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/components/Script.js~Script.html">Script</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/components/Skeleton.js~Skeleton.html">Skeleton</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/components/SortedActions.js~SortedActions.html">SortedActions</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/components/Sprite.js~Sprite.html">Sprite</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/components/TextRenderer.js~TextRenderer.html">TextRenderer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/components/UiLayout.js~UiLayout.html">UiLayout</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/components/UiSprite.js~UiSprite.html">UiSprite</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/components/VerticesRenderer.js~VerticesRenderer.html">VerticesRenderer</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#systems">systems</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/systems/AudioSystem.js~AudioSystem.html">AudioSystem</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/systems/InputSystem.js~InputSystem.html">InputSystem</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/systems/RenderSystem.js~RenderSystem.html">RenderSystem</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/systems/StorageSystem.js~StorageSystem.html">StorageSystem</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/systems/System.js~System.html">System</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#systems-assetsystem">systems/AssetSystem</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/systems/AssetSystem/Asset.js~Asset.html">Asset</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/systems/AssetSystem/index.js~AssetSystem.html">AssetSystem</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#systems-entitysystem">systems/EntitySystem</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/systems/EntitySystem/Component.js~Component.html">Component</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/systems/EntitySystem/Entity.js~Entity.html">Entity</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/systems/EntitySystem/index.js~EntitySystem.html">EntitySystem</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#utils">utils</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/Events.js~Events.html">Events</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-angleDifference">angleDifference</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-bezierCubic">bezierCubic</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-convertGlobalPointToLocalPoint">convertGlobalPointToLocalPoint</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-convertLocalPointToGlobalPoint">convertLocalPointToGlobalPoint</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-findMapKeyOfValue">findMapKeyOfValue</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isGlobalPointInGlobalBoundingBox">isGlobalPointInGlobalBoundingBox</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isLocalPointInLocalBoundingBox">isLocalPointInLocalBoundingBox</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-propsEnumStringify">propsEnumStringify</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-stringToRGBA">stringToRGBA</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-waitForSeconds">waitForSeconds</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/systems/RenderSystem.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import System from &apos;./System&apos;;
import Events from &apos;../utils/Events&apos;;
import { vec4, mat4 } from &apos;../utils/gl-matrix&apos;;

/**
 * Rendering graphics onto screen canvas.
 *
 * @example
 * const system = new RenderSystem(&apos;screen-0&apos;);
 */
export default class RenderSystem extends System {

  /** @type {*} */
  static get propsTypes() {
    return {
      useDevicePixelRatio: &apos;boolean&apos;,
      timeScale: &apos;number&apos;
    };
  }

  /** @type {boolean} */
  get useDevicePixelRatio() {
    return this._useDevicePixelRatio;
  }

  /** @type {boolean} */
  set useDevicePixelRatio(value) {
    this._useDevicePixelRatio = !!value;
  }

  /** @type {number} */
  get timeScale() {
    return this._timeScale;
  }

  /** @type {number} */
  set timeScale(value) {
    if (typeof value !== &apos;number&apos;) {
      throw new Error(&apos;`value` is not type of Number!&apos;);
    }

    this._timeScale = value;
  }

  /** @type {number} */
  get passedTime() {
    return this._passedTime;
  }

  /** @type {HTMLCanvasElement} */
  get canvas() {
    return this._canvas;
  }

  /** @type {Events} */
  get events() {
    return this._events;
  }

  /** @type {string} */
  get activeShader() {
    return this._activeShader;
  }

  /** @type {string} */
  get clearColor() {
    return this._clearColor;
  }

  /** @type {mat4} */
  get projectionMatrix() {
    return this._projectionMatrix;
  }

  /** @type {mat4} */
  get modelViewMatrix() {
    return this._modelViewMatrix;
  }

  /** @type {Map} */
  get stats() {
    return this._stats;
  }

  /**
   * Constructor.
   * Automaticaly binds into specified canvas.
   *
   * @param {string}	canvas - HTML canvas element id.
   * @param {boolean}	optimize - Optimize rendering pipeline.
   * @param {Array.&lt;string&gt;}	extensions - array with WebGL extensions list.
   * @param {number}	contextVersion - WebGL context version number.
   */
  constructor(canvas, optimize = true, extensions = null, contextVersion = 1) {
    super();

    this._extensions = new Map();
    this._contextVersion = contextVersion | 0;
    this._useDevicePixelRatio = false;
    this._timeScale = 1;
    this._animationFrame = 0;
    this._lastTimestamp = null;
    this._canvas = null;
    this._context = null;
    this._shaders = new Map();
    this._textures = new Map();
    this._renderTargets = new Map();
    this._events = new Events();
    this._activeShader = null;
    this._clearColor = vec4.create();
    this._projectionMatrix = mat4.create();
    this._modelViewMatrix = mat4.create();
    this._blendingConstants = {};
    this._stats = new Map();
    this._counterShaderChanges = 0;
    this._counterFrames = 0;
    this._optimize = !!optimize;
    this._passedTime = 0;

    if (!!extensions) {
      for (const name of extensions) {
        this._extensions.set(name, null);
      }
    }
    this._setup(canvas);
  }

  /**
   * Destructor (disposes internal resources).
   *
   * @example
   * system.dispose();
   * sustem = null;
   */
  dispose() {
    const { _context, _shaders, _textures, _renderTargets, _events } = this;

    this._stopAnimation();
    _context.clear(_context.COLOR_BUFFER_BIT);

    for (const shader of _shaders.keys()) {
      this.unregisterShader(shader);
    }
    for (const texture of _textures.keys()) {
      this.unregisterTexture(texture);
    }
    for (const renderTarget of _renderTargets.keys()) {
      this.unregisterRenderTarget(renderTarget);
    }

    _events.dispose();
    this._stats.clear();
  }

  /**
   * Get WebGL extension by it&apos;s name.
   *
   * @param {string}	name - Extension name.
   *
   * @return {*|null} WebGL extension or null if not found.
   *
   * @example
   * const extension = system.extension(&apos;OES_vertex_array_object&apos;);
   * if (!!extension) {
   *   const vao = extension.createVertexArrayOES();
   *   extension.bindVertexArrayOES(vao);
   * }
   */
  extension(name) {
    return this._extensions.get(name) || null;
  }

  /**
   * Register new shader.
   *
   * @param {string}	id - Shader id.
   * @param {string}	vertex - Vertex shader code.
   * @param {string}	fragment - Fragment shader code.
   * @param {*}	layoutInfo - Vertex layout description.
   * @param {*}	uniformsInfo - Uniforms description.
   * @param {*}	samplersInfo - Samplers description.
   * @param {*}	blendingInfo - Blending mode description.
   *
   * @example
   * system.registerShader(
   *   &apos;red&apos;,
   *   &apos;attribute vec2 aPosition;\nvoid main() { gl_Position = vec4(aPosition, 0.0, 1.0); }&apos;,
   *   &apos;void main() { gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); }&apos;,
   *   { aPosition: { size: 2, stride: 2, offset: 0 } },
   *   {},
   *   { source: &apos;src-alpha&apos;, destination: &apos;one-minus-src-alpha&apos; }
   * );
   */
  registerShader(
    id,
    vertex,
    fragment,
    layoutInfo,
    uniformsInfo,
    samplersInfo,
    blendingInfo
  ) {
    if (typeof id !== &apos;string&apos;) {
      throw new Error(&apos;`id` is not type of String!&apos;);
    }
    if (typeof vertex !== &apos;string&apos;) {
      throw new Error(&apos;`vertex` is not type of String!&apos;);
    }
    if (typeof fragment !== &apos;string&apos;) {
      throw new Error(&apos;`fragment` is not type of String!&apos;);
    }
    if (!layoutInfo) {
      throw new Error(&apos;`layoutInfo` cannot be null!&apos;);
    }

    this.unregisterShader(id);

    const gl = this._context;

    const shader = gl.createProgram();
    const vshader = gl.createShader(gl.VERTEX_SHADER);
    const fshader = gl.createShader(gl.FRAGMENT_SHADER);
    const deleteAll = () =&gt; {
      gl.deleteShader(vshader);
      gl.deleteShader(fshader);
      gl.deleteProgram(shader);
    };

    gl.shaderSource(vshader, vertex);
    gl.shaderSource(fshader, fragment);
    gl.compileShader(vshader);
    gl.compileShader(fshader);

    if (!gl.getShaderParameter(vshader, gl.COMPILE_STATUS)) {
      const log = gl.getShaderInfoLog(vshader);
      deleteAll();
      throw new Error(`Cannot compile vertex shader: ${id}\nLog: ${log}`);
    }
    if (!gl.getShaderParameter(fshader, gl.COMPILE_STATUS)) {
      const log = gl.getShaderInfoLog(fshader);
      deleteAll();
      throw new Error(`Cannot compile fragment shader: ${id}\nLog: ${log}`);
    }

    gl.attachShader(shader, vshader);
    gl.attachShader(shader, fshader);
    gl.linkProgram(shader);

    if (!gl.getProgramParameter(shader, gl.LINK_STATUS)) {
      const log = gl.getProgramInfoLog(shader);
      deleteAll();
      throw new Error(`Cannot link shader program: ${id}\nLog: ${log}`);
    }

    const layout = new Map();
    const uniforms = new Map();
    const samplers = new Map();
    let blending = null;

    for (const name in layoutInfo) {
      const { size, stride, offset } = layoutInfo[name];

      if (typeof size !== &apos;number&apos; ||
          typeof stride !== &apos;number&apos; ||
          typeof offset !== &apos;number&apos;
      ) {
        deleteAll();
        throw new Error(
          `Shader layout does not have proper settings: ${id} (${name})`
        );
      }

      const location = gl.getAttribLocation(shader, name);
      if (location &lt; 0) {
        deleteAll();
        throw new Error(
          `Shader does not have attribute: ${id} (${name})`
        );
      }

      layout.set(name, {
        location,
        size,
        stride,
        offset
      });
    }

    if (layout.size === 0) {
      deleteAll();
      throw new Error(`Shader layout cannot be empty: ${id}`);
    }

    if (!!uniformsInfo) {
      for (const name in uniformsInfo) {
        const mapping = uniformsInfo[name];

        if (typeof mapping !== &apos;string&apos; &amp;&amp;
            typeof mapping !== &apos;number&apos; &amp;&amp;
            !(mapping instanceof Array)
        ) {
          deleteAll();
          throw new Error(
            `Shader uniform does not have proper settings: ${id} (${name})`
          );
        }

        const location = gl.getUniformLocation(shader, name);
        if (!location) {
          deleteAll();
          throw new Error(
            `Shader does not have uniform: ${id} (${name})`
          );
        }

        const forcedUpdate =
          mapping === &apos;projection-matrix&apos; ||
          mapping === &apos;model-view-matrix&apos; ||
          mapping === &apos;time&apos; ||
          mapping === &apos;viewport-size&apos; ||
          mapping === &apos;inverse-viewport-size&apos;;

        uniforms.set(name, {
          location,
          mapping,
          forcedUpdate
        });
      }
    }

    if (!!samplersInfo) {
      for (const name in samplersInfo) {
        const { channel, texture, filtering } = samplersInfo[name];

        if (typeof channel !== &apos;number&apos; ||
          (!!texture &amp;&amp; typeof texture !== &apos;string&apos;) ||
          (!!filtering  &amp;&amp; typeof filtering !== &apos;string&apos;)
        ) {
          deleteAll();
          throw new Error(
            `Shader sampler does not have proper settings: ${id} (${name})`
          );
        }

        const location = gl.getUniformLocation(shader, name);
        if (!location) {
          deleteAll();
          throw new Error(
            `Shader does not have sampler: ${id} (${name})`
          );
        }

        samplers.set(name, {
          location,
          channel,
          texture,
          filtering
        });
      }
    }

    if (!!blendingInfo) {
      const { source, destination } = blendingInfo;
      if (typeof source !== &apos;string&apos; || typeof destination !== &apos;string&apos;) {
        throw new Error(`Shader blending does not have proper settings: ${id}`);
      }

      blending = {
        source: this._getBlendingFromName(source),
        destination: this._getBlendingFromName(destination)
      };
    }

    this._shaders.set(id, { shader, layout, uniforms, samplers, blending });
  }

  /**
   * Unregister existing shader.
   *
   * @param {string}	id - Shader id.
   *
   * @example
   * system.unregisterShader(&apos;red&apos;);
   */
  unregisterShader(id) {
    const { _shaders } = this;
    const gl = this._context;
    const meta = _shaders.get(id);

    if (!meta) {
      return;
    }

    const { shader } = meta;
    const shaders = gl.getAttachedShaders(shader);

    for (let i = 0, c = shaders.length; i &lt; c; ++i) {
      gl.deleteShader(shaders[i]);
    }
    gl.deleteProgram(shader);
    _shaders.delete(id);
  }

  /**
   * Enable given shader (make it currently active for further rendering).
   *
   * @param {string}	id - Shader id.
   * @param {boolean}	forced - ignore optimizations (by default it will not enable if is currently active).
   *
   * @example
   * system.enableShader(&apos;red&apos;);
   */
  enableShader(id, forced = false) {
    const {
      _shaders,
      _textures,
      _activeShader,
      _projectionMatrix,
      _modelViewMatrix,
      _optimize,
      _passedTime
    } = this;
    const changeShader = forced || _activeShader !== id || !_optimize;
    const gl = this._context;
    const meta = _shaders.get(id);

    if (!meta) {
      console.warn(`Trying to enable non-existing shader: ${id}`);
      return;
    }

    const { shader, layout, uniforms, samplers, blending } = meta;

    if (changeShader) {
      gl.useProgram(shader);
      this._activeShader = id;
      ++this._counterShaderChanges;
    }

    for (const { location, size, stride, offset } of layout.values()) {
      gl.vertexAttribPointer(
        location,
        size,
        gl.FLOAT,
        false,
        stride * 4,
        offset * 4
      );
      gl.enableVertexAttribArray(location);
    }

    for (const { location, mapping, forcedUpdate } of uniforms.values()) {
      const { length } = mapping;

      if (mapping === &apos;&apos; || (!changeShader &amp;&amp; !forcedUpdate)) {
        continue;

      } else if (mapping === &apos;projection-matrix&apos;) {
        gl.uniformMatrix4fv(location, false, _projectionMatrix);

      } else if (mapping === &apos;model-view-matrix&apos;) {
        gl.uniformMatrix4fv(location, false, _modelViewMatrix);

      } else if (mapping === &apos;time&apos;) {
        gl.uniform1f(location, _passedTime * 0.001);

      } else if (mapping === &apos;viewport-size&apos;) {
        gl.uniform2f(location, this._canvas.width, this._canvas.height);

      } else if (mapping === &apos;inverse-viewport-size&apos;) {
        const { width, height } = this._canvas;

        gl.uniform2f(
          location,
          width === 0 ? 1 : 1 / width,
          height === 0 ? 1 : 1 / height
        );

      } else if (typeof mapping === &apos;number&apos;) {
        gl.uniform1f(location, mapping);

      } else if (length === 2) {
        gl.uniform2fv(location, mapping);

      } else if (length === 3) {
        gl.uniform3fv(location, mapping);

      } else if (length === 4) {
        gl.uniform4fv(location, mapping);

      } else if (length === 9) {
        gl.uniformMatrix3fv(location, false, mapping);

      } else if (length === 16) {
        gl.uniformMatrix4fv(location, false, mapping);

      } else {
        console.warn(`Trying to set non-proper uniform: ${name} (${id})`);
      }
    }

    if (!changeShader) {
      return;
    }

    for (const { location, channel, texture, filtering } of samplers.values()) {
      if (texture === &apos;&apos;) {
        continue;
      }

      const tex = _textures.get(texture);
      if (!tex) {
        console.warn(`Trying to enable non-existing texture: ${texture} (${id})`);
        continue;
      }

      const mode = filtering === &apos;linear&apos;
        ? gl.LINEAR
        : gl.NEAREST;

      gl.activeTexture(gl.TEXTURE0 + channel | 0);
      gl.bindTexture(gl.TEXTURE_2D, tex.texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, mode);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, mode);
      gl.uniform1i(location, channel | 0);
    }

    if (!!blending) {
      gl.enable(gl.BLEND);
      gl.blendFunc(blending.source, blending.destination);
    } else {
      gl.disable(gl.BLEND);
    }
  }

  /**
   * Disable given shader.
   * Make sure that this is currently active shader (otherwise it will unbind wrong shader locations)!
   *
   * @param {string}	id - Shader id.
   *
   * @example
   * const id = &apos;red&apos;;
   * system.enableShader(id);
   * system.disableShader(id);
   */
  disableShader(id) {
    const { _shaders } = this;
    const gl = this._context;
    const meta = _shaders.get(id);

    if (!meta) {
      console.warn(`Trying to disable non-existing shader: ${id}`);
      return;
    }

    const { layout } = meta;

    for (const { location } of layout.values()) {
      gl.disableVertexAttribArray(location);
    }
  }

  /**
   * Give active shader uniform a different than it&apos;s default value.
   *
   * @param {string}	name - Uniform name.
   * @param {*}	value - Uniform value. Can be number of array of numbers.
   *
   * @example
   * system.enableShader(&apos;color&apos;);
   * system.overrideShaderUniform(&apos;uColor&apos;, [1, 0, 0, 1]);
   */
  overrideShaderUniform(name, value) {
    const { _shaders, _activeShader } = this;
    const gl = this._context;
    const meta = _shaders.get(_activeShader);

    if (!meta) {
      console.warn(`Trying to set uniform of non-existing shader: ${_activeShader}`);
      return;
    }

    const { uniforms } = meta;
    const uniform = uniforms.get(name);

    if (!uniform) {
      console.warn(`Trying to set value of non-existing uniform: ${_activeShader} (${name})`);
      return;
    }

    const { location } = uniform;
    const { length } = value;

    if (typeof value === &apos;number&apos;) {
      gl.uniform1f(location, value);

    } else if (length === 2) {
      gl.uniform2fv(location, value);

    } else if (length === 3) {
      gl.uniform3fv(location, value);

    } else if (length === 4) {
      gl.uniform4fv(location, value);

    } else if (length === 9) {
      gl.uniformMatrix3fv(location, false, value);

    } else if (length === 16) {
      gl.uniformMatrix4fv(location, false, value);

    }
  }

  /**
   * Give active shader sampler different than it&apos;s default texture.
   *
   * @param {string}	name - Sampler id.
   * @param {string}	texture - Texture id.
   * @param {string}	filtering - Sampler filtering. Can be linear or nearest.
   *
   * @example
   * system.enableShader(&apos;sprite&apos;);
   * system.overrideShaderSampler(&apos;sTexture&apos;, &apos;marsian&apos;, &apos;linear&apos;);
   */
  overrideShaderSampler(name, texture, filtering) {
    const { _shaders, _textures, _activeShader } = this;
    const gl = this._context;
    const meta = _shaders.get(_activeShader);

    if (!meta) {
      console.warn(`Trying to set sampler of non-existing shader: ${_activeShader}`);
      return;
    }

    const { samplers } = meta;
    const sampler = samplers.get(name);

    if (!sampler) {
      console.warn(`Trying to set non-existing sampler: ${_activeShader} (${name})`);
      return;
    }

    const tex = _textures.get(texture);
    if (!tex) {
      console.warn(`Trying to enable non-existing texture: ${texture} (${texture})`);
      return;
    }

    const { location, channel } = sampler;
    const mode = filtering === &apos;linear&apos;
      ? gl.LINEAR
      : gl.NEAREST;

    gl.activeTexture(gl.TEXTURE0 + channel | 0);
    gl.bindTexture(gl.TEXTURE_2D, tex.texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, mode);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, mode);
    gl.uniform1i(location, channel | 0);
  }

  /**
   * Register new texture.
   *
   * @param {string}	id - Texture id.
   * @param {HTMLImageElement}	image - Image instance.
   *
   * @example
   * const image = new Image();
   * image.src = &apos;marsian.png&apos;;
   * system.registerTexture(&apos;marsian&apos;, image);
   */
  registerTexture(id, image) {
    this.unregisterTexture(id);

    const gl = this._context;

    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.bindTexture(gl.TEXTURE_2D, null);

    this._textures.set(id, {
      texture,
      width: image.width,
      height: image.height
    });
  }

  /**
   * Register empty texture (mostly usedin  offscreen rendering cases).
   *
   * @param {string}	id - Texture id.
   * @param {number}	width - Width.
   * @param {number}	height - Height.
   * @param {boolean}	floatPointData - Tells if this texture will store floating point data.
   *
   * @example
   * system.registerTextureEmpty(&apos;offscreen&apos;, 512, 512);
   */
  registerTextureEmpty(id, width, height, floatPointData = false) {
    this.unregisterTexture(id);

    const gl = this._context;
    width = Math.max(1, width | 0);
    height = Math.max(1, height | 0);

    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(
      gl.TEXTURE_2D,
      0,
      gl.RGBA,
      width,
      height,
      0,
      gl.RGBA,
      !!floatPointData ? gl.FLOAT : gl.UNSIGNED_BYTE,
      null
    );
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.bindTexture(gl.TEXTURE_2D, null);

    this._textures.set(id, {
      texture,
      width,
      height
    });
  }

  /**
   * Unregister existing texture.
   *
   * @param {string}	id - Texture id.
   *
   * @example
   * system.unregisterTexture(&apos;red&apos;);
   */
  unregisterTexture(id) {
    const { _textures } = this;
    const gl = this._context;
    const texture = _textures.get(id);

    if (!!texture) {
      gl.deleteTexture(texture.texture);
      _textures.delete(id);
    }
  }

  /**
   * Get texture meta information (width and height).
   *
   * @param {string}	id - Texture id.
   *
   * @return {*|null} Object with width and height properties or null if not found.
   */
  getTextureMeta(id) {
    const { _textures } = this;
    const texture = _textures.get(id);

    return !!texture
      ? { width: texture.width, height: texture.height }
      : null;
  }

  /**
   * Register new render target.
   *
   * @param {string}	id - Render target id.
   * @param {number}	width - Width.
   * @param {number}	height - Height.
   * @param {boolean}	floatPointData - Tells if render target will store floating point data.
   *
   * @example
   * system.registerRenderTarget(&apos;offscreen&apos;, 512, 512);
   */
  registerRenderTarget(id, width, height, floatPointData = false) {
    this.unregisterRenderTarget(id);

    const gl = this._context;
    width = Math.max(1, width);
    height = Math.max(1, height);

    this.registerTextureEmpty(id, width, height, floatPointData);
    const texture = this._textures.get(id);
    if (!texture) {
      return;
    }

    const target = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, target);
    gl.framebufferTexture2D(
      gl.FRAMEBUFFER,
      gl.COLOR_ATTACHMENT0,
      gl.TEXTURE_2D,
      texture.texture,
      0
    );
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);

    this._renderTargets.set(id, {
      target,
      width,
      height
    });
  }

  /**
   * Unregister existing render target.
   *
   * @param {string}	id - Render target id.
   *
   * @example
   * system.unregisterRenderTarget(&apos;offscreen&apos;);
   */
  unregisterRenderTarget(id) {
    this.unregisterTexture(id);

    const { _renderTargets } = this;
    const gl = this._context;
    const target = _renderTargets.get(id);

    if (!!target) {
      gl.deleteFramebuffer(target.target);
      _renderTargets.delete(id);
    }
  }

  /**
   * Get render target meta information (width and height).
   *
   * @param {string}	id - Texture id.
   *
   * @return {*|null} Object with width and height properties or null if not found.
   */
  getRenderTargetMeta(id) {
    const { _renderTargets } = this;
    const target = _renderTargets.get(id);

    return !!target
      ? { width: target.width, height: target.height }
      : null;
  }

  /**
   * Make given render target active for further rendering.
   *
   * @param {string}	id - Render target id.
   *
   * @example
   * system.enableRenderTarget(&apos;offscreen&apos;);
   */
  enableRenderTarget(id) {
    const { _renderTargets } = this;
    const gl = this._context;
    const target = _renderTargets.get(id);
    if (!target) {
      this.disableRenderTarget();
      return;
    }

    gl.bindFramebuffer(gl.FRAMEBUFFER, target.target);
    gl.viewport(0, 0, target.width, target.height);
    gl.clear(gl.COLOR_BUFFER_BIT);
  }

  /**
   * Disable active render target.
   *
   * @example
   * system.disableRenderTarget();
   */
  disableRenderTarget() {
    const { _context, _canvas } = this;

    _context.bindFramebuffer(_context.FRAMEBUFFER, null);
    _context.viewport(0, 0, _canvas.width, _canvas.height);
  }

  /**
   * Tells if there is registered given shader.
   *
   * @param {string}	id - Shader id.
   *
   * @return {boolean}
   */
  hasShader(id) {
    return !!this._shaders.get(id);
  }

  /**
   * Tells if there is registered given texture.
   *
   * @param {string}	id - Texture id.
   *
   * @return {boolean}
   */
  hasTexture(id) {
    return !!this._textures.get(id);
  }

  /**
   * Tells if there is registered given render target.
   *
   * @param {string}	id - Render target id.
   *
   * @return {boolean}
   */
  hasRenderTarget(id) {
    return !!this._renderTargets.get(id);
  }

  /**
   * Resize frame buffer to match canvas size.
   *
   * @param {boolean}	forced - True if ignore optimizations.
   */
  resize(forced = false) {
    const { _canvas, _context } = this;
    let { width, height, clientWidth, clientHeight } = _canvas;

    if (this._useDevicePixelRatio) {
      const { devicePixelRatio } = window;

      clientWidth = (clientWidth * devicePixelRatio) | 0;
      clientHeight = (clientHeight * devicePixelRatio) | 0;
    }

    if (forced || width !== clientWidth || height !== clientHeight) {
      _canvas.width = clientWidth;
      _canvas.height = clientHeight;
      _context.viewport(0, 0, clientWidth, clientHeight);
      this._events.trigger(&apos;resize&apos;, clientWidth, clientHeight);
    }
  }

  /**
   * @override
   */
  onRegister() {
    this._startAnimation();
  }

  /**
   * @override
   */
  onUnregister() {
    this._stopAnimation();
  }

  _setup(canvas) {
    if (typeof canvas !== &apos;string&apos;) {
      throw new Error(&apos;`canvas` is not type of String!&apos;);
    }

    canvas = this._canvas = document.getElementById(canvas);

    const { _contextVersion } = this;
    const options = {
      alpha: false,
      depth: false,
      stencil: false,
      antialias: false,
      premultipliedAlpha: false,
      preserveDrawingBuffer: false,
      failIfMajorPerformanceCaveat: false
    };
    const contextName = _contextVersion === 1
      ? &apos;webgl&apos;
      : `webgl${_contextVersion}`;
    const gl = this._context =
      canvas.getContext(contextName, options) ||
      canvas.getContext(`experimental-${contextName}`, options);

    if (!gl) {
      throw new Error(`Cannot create WebGL context: ${contextName}`);
    }

    for (const name of this._extensions.keys()) {
      const ext = gl.getExtension(name);
      if (!!ext) {
        this._extensions.set(name, ext);
      } else {
        console.warn(`Could not get WebGL extension: ${name}`);
      }
    }

    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.clearColor(0.0, 0.0, 0.0, 0.0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    this._blendingConstants = {
      &apos;zero&apos;: gl.ZERO,
      &apos;one&apos;: gl.ONE,
      &apos;src-color&apos;: gl.SRC_COLOR,
      &apos;one-minus-src-color&apos;: gl.ONE_MINUS_SRC_COLOR,
      &apos;dst-color&apos;: gl.DST_COLOR,
      &apos;one-minus-dst-color&apos;: gl.ONE_MINUS_DST_COLOR,
      &apos;src-alpha&apos;: gl.SRC_ALPHA,
      &apos;one-minus-src-alpha&apos;: gl.ONE_MINUS_SRC_ALPHA,
      &apos;dst-alpha&apos;: gl.DST_ALPHA,
      &apos;one-minus-dst-alpha&apos;: gl.ONE_MINUS_DST_ALPHA,
      &apos;constant-color&apos;: gl.CONSTANT_COLOR,
      &apos;one-minus-constant-color&apos;: gl.ONE_MINUS_CONSTANT_COLOR,
      &apos;constant-alpha&apos;: gl.CONSTANT_ALPHA,
      &apos;one-minus-constant-alpha&apos;: gl.ONE_MINUS_CONSTANT_ALPHA,
      &apos;src-alpha-saturate&apos;: gl.SRC_ALPHA_SATURATE
    };
  }

  _startAnimation() {
    this._stopAnimation();

    this._passedTime = 0;
    this._lastTimestamp = performance.now();
    this._requestFrame();
  }

  _stopAnimation() {
    cancelAnimationFrame(this._animationFrame);
    this._passedTime = 0;
    this._lastTimestamp = null;
  }

  _requestFrame() {
    this._animationFrame = requestAnimationFrame(
      timestamp =&gt; this._onFrame(timestamp)
    );
  }

  _onFrame(timestamp) {
    this.resize();

    const { _clearColor, _stats, _counterShaderChanges } = this;
    const [ cr, cg, cb, ca ] = _clearColor;
    const gl = this._context;
    const deltaTime = (timestamp - this._lastTimestamp) * this._timeScale;
    this._passedTime += deltaTime;
    this._lastTimestamp = timestamp;
    this._counterShaderChanges = 0
    this._activeShader = null;

    gl.clearColor(cr, cg, cb, ca);
    gl.clear(gl.COLOR_BUFFER_BIT);
    this.events.trigger(&apos;render&apos;, gl, this, deltaTime);

    _stats.set(&apos;delta-time&apos;, deltaTime);
    _stats.set(&apos;passed-time&apos;, this._passedTime);
    _stats.set(&apos;shader-changes&apos;, _counterShaderChanges);
    _stats.set(&apos;frames&apos;, ++this._counterFrames);
    _stats.set(&apos;shaders&apos;, this._shaders.size);
    _stats.set(&apos;textures&apos;, this._textures.size);

    this._requestFrame();
  }

  _getBlendingFromName(name) {
    const { _blendingConstants } = this;

    if (!(name in _blendingConstants)) {
      throw new Error(`There is no blending function: ${name}`);
    }

    return _blendingConstants[name];
  }

}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.0.4)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
